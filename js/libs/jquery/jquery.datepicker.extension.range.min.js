/* jQuery ui-datepicker extension */

/**
 *
 * https://gist.github.com/Artemeey/8bacd37964a8069a2eeee8c9b0bd2e44/
 *
 * Version: 1.0 (15.06.2016)
 * Requires: jQuery v1.8+
 * Requires: jQuery-UI v1.10+
 *
 * Copyright (c) 2016 Artemeey
 * Under MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 *
 * sample:
 * $('.datepicker').datepicker({
		range:'period', // 'period' or 'multiple'
		onSelect:function(dateText, inst, extensionRange){
			// range - new argument!
			switch(inst.settings.range){
				case 'period':
					console.log(extensionRange.startDateText);
					console.log(extensionRange.endDateText);
					console.log(extensionRange.startDate);
					console.log(extensionRange.endDate);
					break;
				case 'multiple':
					console.log(extensionRange.dates); // object, width UTC-TIME keys
					console.log(extensionRange.datesText); // object, width UTC-TIME keys
					break;
			}
		}
	});
 *
 * extension styles:
 * .selected
 * .selected-start
 * .selected-end
 * .first-of-month
 * .last-of-month
 *
 */

//  $.datepicker._get_original=$.datepicker._get,$.datepicker._get=function(t,e){var i=$.datepicker._get_original(t,e),a=t.settings.range;if(!a)return i;var s=this;switch(a){case"period":case"multiple":var n=$(this.dpDiv).data("datepickerExtensionRange");switch(n||(n=new _datepickerExtension,$(this.dpDiv).data("datepickerExtensionRange",n)),n.range=a,n.range_multiple_max=t.settings.range_multiple_max||0,e){case"onSelect":var r=i;r||(r=function(){}),i=function(t,e){n.onSelect(t,e),r(t,e,n),s._datepickerShowing=!1,setTimeout(function(){s._updateDatepicker(e),s._datepickerShowing=!0}),n.setClassActive(e)};break;case"beforeShowDay":var r=i;r||(r=function(){return[!0,""]}),i=function(t){var e=r(t);return e=n.fillDay(t,e)};break;case"beforeShow":var r=i;r||(r=function(){}),i=function(t,e){r(t,e),n.setClassActive(e)};break;case"onChangeMonthYear":var r=i;r||(r=function(){}),i=function(t,e,i){r(t,e,i),n.setClassActive(i)}}}return i},$.datepicker._setDate_original=$.datepicker._setDate,$.datepicker._setDate=function(t,e,i){var a=t.settings.range;if(!a)return $.datepicker._setDate_original(t,e,i);var s=this.dpDiv.data("datepickerExtensionRange");if(!s)return $.datepicker._setDate_original(t,e,i);switch(a){case"period":("object"!=typeof e||void 0==e.length)&&(e=[e,e]),s.step=0,$.datepicker._setDate_original(t,e[0],i),s.startDate=this._getDate(t),s.startDateText=this._formatDate(t),$.datepicker._setDate_original(t,e[1],i),s.endDate=this._getDate(t),s.endDateText=this._formatDate(t),s.setClassActive(t);break;case"multiple":("object"!=typeof e||void 0==e.length)&&(e=[e]),s.dates=[],s.datesText=[];var n=this;$.map(e,function(e){$.datepicker._setDate_original(t,e,i),s.dates.push(n._getDate(t)),s.datesText.push(n._formatDate(t))}),s.setClassActive(t)}};var _datepickerExtension=function(){this.range=!1,this.range_multiple_max=0,this.step=0,this.dates=[],this.datesText=[],this.startDate=null,this.endDate=null,this.startDateText="",this.endDateText="",this.onSelect=function(t,e){switch(this.range){case"period":return this.onSelectPeriod(t,e);case"multiple":return this.onSelectMultiple(t,e)}},this.onSelectPeriod=function(t,e){this.step++,this.step%=2,this.step?(this.startDate=this.getSelectedDate(e),this.endDate=this.startDate,this.startDateText=t,this.endDateText=this.startDateText):(this.endDate=this.getSelectedDate(e),this.endDateText=t,this.startDate.getTime()>this.endDate.getTime()&&(this.endDate=this.startDate,this.startDate=this.getSelectedDate(e),this.endDateText=this.startDateText,this.startDateText=t))},this.onSelectMultiple=function(t,e){var i=this.getSelectedDate(e),a=-1;$.map(this.dates,function(t,e){t.getTime()==i.getTime()&&(a=e)});var s=$.inArray(t,this.datesText);-1!=a?this.dates.splice(a,1):this.dates.push(i),-1!=s?this.datesText.splice(s,1):this.datesText.push(t),this.range_multiple_max&&this.dates.length>this.range_multiple_max&&(this.dates.splice(0,1),this.datesText.splice(0,1))},this.fillDay=function(t,e){var i=e[1];switch(1==t.getDate()&&(i+=" first-of-month"),t.getDate()==new Date(t.getFullYear(),t.getMonth()+1,0).getDate()&&(i+=" last-of-month"),e[1]=i.trim(),this.range){case"period":return this.fillDayPeriod(t,e);case"multiple":return this.fillDayMultiple(t,e)}},this.fillDayPeriod=function(t,e){if(!this.startDate||!this.endDate)return e;var i=e[1];return t>=this.startDate&&t<=this.endDate&&(i+=" selected"),t.getTime()==this.startDate.getTime()&&(i+=" selected-start"),t.getTime()==this.endDate.getTime()&&(i+=" selected-end"),e[1]=i.trim(),e},this.fillDayMultiple=function(t,e){var i=e[1],a=!1;return $.map(this.dates,function(e){e.getTime()==t.getTime()&&(a=!0)}),a&&(i+=" selected selected-start selected-end"),e[1]=i.trim(),e},this.getSelectedDate=function(t){return new Date(t.selectedYear,t.selectedMonth,t.selectedDay)},this.setClassActive=function(t){var e=this;setTimeout(function(){$("td.selected > *",t.dpDiv).addClass("ui-state-active"),"multiple"==e.range&&$("td:not(.selected)",t.dpDiv).removeClass("ui-datepicker-current-day").children().removeClass("ui-state-active")})}};
($.datepicker._get_original = $.datepicker._get),
    ($.datepicker._get = function (t, e) {

        var i = $.datepicker._get_original(t, e),
            a = t.settings.range;
        if (!a) return i;
        var s = this;
        // console.log(s)
        // var target = $( id );
        // var inst = this._getInst( target[ 0 ] );
        // console.log(this._get( inst, "TLctx" ))
        // console.log("T",  t.settings.TLctx)
        // console.log(e)
        var TLctx = t.settings.TLctx
        // console.log("t.TLctx", t)
        switch (a) {
            case "period":
            case "multiple":
                var n = $(this.dpDiv).data("datepickerExtensionRange");


                switch ((n || ((n = new _datepickerExtension(TLctx)), $(this.dpDiv).data("datepickerExtensionRange", n)), (n.range = a), (n.range_multiple_max = t.settings.range_multiple_max || 0), e)) {
                    case "onSelect":
                        var r = i;
                        r || (r = function () {}),
                            (i = function (t, e) {
                                n.onSelect(t, e),
                                    r(t, e, n),
                                    (s._datepickerShowing = !1),
                                    setTimeout(function () {
                                        // console.log("datepicker", e)
                                        // console.log("datepicker", TLctx)
                                        TLctx.datepicker = s
                                        TLctx.inst = e
                                        s._updateDatepicker(e), (s._datepickerShowing = !0);
                                    }),
                                    n.setClassActive(e);
                            });
                        break;
                    case "onUpdateDatepicker":
                        var r = i;
                        // console.log(r) // Это и есть наша функция, которую мы сюда кладем.
                        // console.log(n) // Это _datepickerExtension
                        r
                        // r || (r = function () {}),
                        //     (i = function (t, e) {
                        //         n.onUpdateDatepicker(t, e),
                        //             r(t, e, n),
                        //             (s._datepickerShowing = !1),
                        //             setTimeout(function () {
                        //                 s._updateDatepicker(e), (s._datepickerShowing = !0);
                        //             }),
                        //             n.setClassActive(e);
                        //             console.log("e", e)
                        //     });
                        break;
                    case "beforeShowDay":
                        var r = i;
                        // console.log("t.sett", t.settings)
                        r ||
                            (r = function () {
                                return [!0, ""];
                            }),
                            (i = function (t) {
                                var e = r(t);
                                // console.log("fdt", t)
                                // console.log("fde", e)
                                // console.log(TLctx)
                                return (e = n.fillDay(t, e)); // ЗДЕСЬ 1
                            });
                        break;
                    case "beforeShow":
                        var r = i;
                        r || (r = function () {}),
                            (i = function (t, e) {
                                r(t, e), n.setClassActive(e);
                            });
                        break;
                    case "onChangeMonthYear":
                        var r = i;
                        r || (r = function () {}),
                            (i = function (t, e, i) {
                                r(t, e, i), n.setClassActive(i);
                            });
                }
        }
        return i;
    }),
    ($.datepicker._setDate_original = $.datepicker._setDate),
    ($.datepicker._setDate = function (t, e, i) {
        // ЗДЕСЬ 2
        var a = t.settings.range;
        if (!a) return $.datepicker._setDate_original(t, e, i);
        var s = this.dpDiv.data("datepickerExtensionRange");

        var TLctx = this._get( t, "TLctx" );
        // console.log("_setDate t", t)
        // console.log("_setDate e", e)
        // console.log("_setDate i", i)

        if (!s) return $.datepicker._setDate_original(t, e, i);
        switch (a) {
            case "period":
                ("object" != typeof e || void 0 == e.length) && (e = [e, e]),
                    (s.step = 0),
                    $.datepicker._setDate_original(t, e[0], i),
                    (s.startDate = this._getDate(t)),
                    (s.startDateText = this._formatDate(t)),
                    $.datepicker._setDate_original(t, e[1], i),
                    (s.endDate = this._getDate(t)),
                    (s.endDateText = this._formatDate(t)),
                    s.setClassActive(t);
                break;
            case "multiple":
                ("object" != typeof e || void 0 == e.length) && (e = [e]), (s.dates = []), (s.datesText = []);
                var n = this;
                // console.log("n", n)
                // console.log("e", e)
                // console.log("t", t)
                // console.log("i", i)

                console.log("_setDate timenodes 1", TLctx.current.timenodes)

                // ПРОИСХОДИТ ТОЛЬКО 1 РАЗ ПРИ СТАРТЕ КАЛЕНДАРЯ, ВИДИМО.
                // console.log("123 TLctx",TLctx)
                let totalMatchFound = false
                TLctx.current.timenodes.forEach(item => {
                    // console.log("123", TLctx.current.timenodes)
                    // CTX - AUTOFILL PREDEFINED DATA
                    // Либо изначально добавлять в current.timenodes только те timenodes, которые подходят под все выбранные фильтры.
                    console.log("item", item)
                    // 1. item.hours != null. Тогда выделяем ячейку и указываем время на отрисовках.
                    // 2. item.hours == null. Тогда снимаем выделение у ячейки и не указываем время на отрисовках.
                    let contextMatch = item.smena == TLctx.current.smena && item.workType == TLctx.current.workType && TLctx.current.object == item.object
                    totalMatchFound = contextMatch && item.date == TLctx.current.date ? true : totalMatchFound
                    if (contextMatch) {
                        if (item.hours != null && item.date != TLctx.current.date) {
                            // console.log(TLctx.current)
                            console.log("очередная pre-defined date", item)
                            // console.log("очередная pre-defined date", item.date)
                            let date = item.date.split(".")
                            let e = new Date(date[2], date[1]-1, date[0])
                            $.datepicker._setDate_original(t, e, i), s.dates.push(n._getDate(t)), s.datesText.push(n._formatDate(t));
                        }
                    }
                })
                // if (!totalMatchFound) {
                //     var el = {
                //         object: TLctx.current.object,
                //         smena: TLctx.current.smena,
                //         workType: TLctx.current.workType,
                //         date: TLctx.current.date,
                //         hours: TLctx.current.hours,
                //     }
                //     TLctx.current.timenodes.push(el)
                // }

                $.map(e, function (e) {
                    // Именно здесь происходит добавление первоначальной даты (которая дефолтная, которая сегодня и нужна чтобы вывести текущий месяц а не 1990 год) в контейнер.
                    // (здесь inst - буква t, дата - буква e, noChange - i)
                    // Значит вопрос в том, чтобы в случае если пользователь не выбирал дату - не добавлять сегодняшнюю.
                    // Т.е. нужна проверка - если date == current date && init == true, как вариант, то сюда в контейнер ничего не добавлять и ничего не отрисовывать тоже.
                    // или пойти через разграничение currentDate и selectedDate, причем устанавливать selectedDate = null, и сравнивать для отрисовки - если
                    // selectedDate = null то не отрисовывать,при этом selectedDate = Date если выбрано пользователем через хендлер selectDay

                    $.datepicker._setDate_original(t, e, i), s.dates.push(n._getDate(t)), s.datesText.push(n._formatDate(t));
                }),
                console.log("<ERFDF", t)
                s.setClassActive(t); // Важный момент. Именно этой командой становится доступно множественный чек.
                if (t.settings.init == true) {
                    s.dates.pop(n._getDate(t)), s.datesText.pop(n._formatDate(t)), t.settings.init = false; };
                // console.log(1234)
                console.log("_setDate timenodes 2", TLctx.current.timenodes)

        }
    });
var _datepickerExtension = function (TLctx) {

    (this.range = !1),
        (this.range_multiple_max = 0),
        (this.step = 0),
        (this.dates = []),
        (this.datesText = []),
        (this.startDate = null),
        (this.endDate = null),
        (this.startDateText = ""),
        (this.endDateText = ""),
        (this.onSelect = function (t, e) {
            switch (this.range) {
                case "period":
                    return this.onSelectPeriod(t, e);
                case "multiple":
                    return this.onSelectMultiple(t, e);
            }
        }),
        (this.onSelectPeriod = function (t, e) {
            this.step++,
                (this.step %= 2),
                this.step
                    ? ((this.startDate = this.getSelectedDate(e)), (this.endDate = this.startDate), (this.startDateText = t), (this.endDateText = this.startDateText))
                    : ((this.endDate = this.getSelectedDate(e)),
                      (this.endDateText = t),
                      this.startDate.getTime() > this.endDate.getTime() && ((this.endDate = this.startDate), (this.startDate = this.getSelectedDate(e)), (this.endDateText = this.startDateText), (this.startDateText = t)));
        }),
        (this.onSelectMultiple = function (t, e) {
            // Происходит при каждом клике.
            // console.log("clickedDate", t, "instance", e);
            var TLctx = e.settings.TLctx

            var i = this.getSelectedDate(e),
                a = -1;
            var deselect = 1


            TLctx.current.timenodes.forEach(e => {
                // console.log(t) // Кликнутая дата в текстовом формате
                let date = e.date.split(".")
                date = new Date(date[2], date[1]-1, date[0])
                if ( date == t && e.hours != null) { // Если даты совпадают и есть инфа по часам
                    // console.log("utl", TLctx)
                    // console.log("t", t)
                    deselect = 0
                    // console.log("mdeee//// e", e)
                }

            })
            // TLctx.setCurrentTimenodesByDate(TLctx, t)
            $.map(this.dates, function (t, e) {
                t.getTime() == i.getTime() && (a = e);
            });
            var s = $.inArray(t, this.datesText);
            -1 != a && !deselect ? this.dates.splice(a, 1) : this.dates.push(i),
                -1 != s && !deselect ? this.datesText.splice(s, 1) : this.datesText.push(t),
                this.range_multiple_max && this.dates.length > this.range_multiple_max && (this.dates.splice(0, 1), this.datesText.splice(0, 1));
                // console.log("clickedDate", t, "instance", e, "dates", this.datesText);
        }),
        (this.fillDay = function (t, e) {

            var i = e[1];
            switch ((1 == t.getDate() && (i += " first-of-month"), t.getDate() == new Date(t.getFullYear(), t.getMonth() + 1, 0).getDate() && (i += " last-of-month"), (e[1] = i.trim()), this.range)) {
                case "period":
                    return this.fillDayPeriod(t, e);
                case "multiple":
                    return this.fillDayMultiple(t, e);
            }
        }),
        (this.fillDayPeriod = function (t, e) {
            if (!this.startDate || !this.endDate) return e;
            var i = e[1];
            return t >= this.startDate && t <= this.endDate && (i += " selected"), t.getTime() == this.startDate.getTime() && (i += " selected-start"), t.getTime() == this.endDate.getTime() && (i += " selected-end"), (e[1] = i.trim()), e;
        }),
        (this.fillDayMultiple = function (t, e) {
            var i = e[1],
                a = !1;
                // console.log(a)
                // Логика: если часы выбранной даты != null, то ставим тег .selected, иначе убираем его.
                var select = false
                TLctx.current.timenodes.forEach(e => {
                    let date = e.date.split(".")
                    date = new Date(date[2], date[1]-1, date[0])
                    let currentContext = TLctx.current
                    let contextMatch = e.object == currentContext.object && e.smena == currentContext.smena && e.workType == currentContext.workType
                    let totalMatch = contextMatch && e.date == TLctx.current.date
                    let dateMatch = e.date == TLctx.current.date
                    if ( date.getTime() == t.getTime() && contextMatch) { // Если даты совпадают и есть инфа по часам


                        // console.log("t", t)
                        let action = TLctx.current.hoursAction
                        let removeCase = action == "remove" && contextMatch && TLctx.current.hours == null
                        let updateCase = action == "update" && contextMatch && TLctx.current.hours != null
                        let backCase = action == "back" && contextMatch

                        let initCase = action == undefined && contextMatch
                        // console.log('fillDayMultiple', date, action, removeCase, updateCase, backCase)

                        if ( e.hours == null ) {
                            select = initCase ? false
                            : removeCase && dateMatch ? false
                            : updateCase && dateMatch ? false
                            : backCase ? false
                            : false
                        } else if (e.hours != null) {
                            select = initCase ? true
                            : removeCase && dateMatch ? false
                            : updateCase && dateMatch ? true
                            : backCase ? true
                            : true
                        }

                        // console.log("mdeee//// e fdm", e, select)

                    }
                })
                // console.log("utl", TLctx)
                // Нужно связать select именно с очередной датой. Каждый раз крутится цикл, но применяется только к одной дате, которая
                // console.log("mdeee//// t fdm", t, select)

                // Здесь, в случае "remove", должен происходить обратный процесс. Т.е. select = !select
                // Еще не совсем понятно как select из контекста цикла вдруг заходит в return без привязки к массиву items. Получается некое случайное попадание, которое работает просто потому что до этого была куча отсеивающих проверок.
            return (
                $.map(this.dates, function (e) {
                    e.getTime() == t.getTime() && (a = !0); // Если даты совпадают
                }),
                select && (a = !0) && (i += " selected selected-start selected-end"), // Здесь цепляются теги в случае совпадения дат - только при клике.
                (e[1] = i.trim()),
                // console.log(e, a, select),
                e
            );
        }),
        (this.getSelectedDate = function (t) {
            return new Date(t.selectedYear, t.selectedMonth, t.selectedDay);
        }),
        (this.setClassActive = function (t) {
            var e = this;
            setTimeout(function () {
                $("td.selected > *", t.dpDiv).addClass("ui-state-active"), "multiple" == e.range && $("td:not(.selected)", t.dpDiv).removeClass("ui-datepicker-current-day").children().removeClass("ui-state-active");
            });
        });
};
